{
    "Modeling and Impact":{
        "Program Level": "Understand, guide, shape impact of computing on society/the world",
        "Theory":" Modeling & Application: Connect the role of theory to other applications (in undergraduate CS curriculum and beyond). Model problems using appropriate mathematical concepts",
        "Children":{
            "Modeling": {
                "Description": "Model systems with tools from discrete mathematics and reason about implications of modelling choices",
                "Children": {},
                "Icon": "MD" 
            },
            "Boolean Operations": {
                "Description" : "Relate boolean operations to applications, e.g. set operations and combinatorial circuits.",
                "Children":{
                    "XOR and Bit Shifts":"Correctly use XOR and bit shifts",
                    "Clustering":"Define clustering as an application of relations and partitions"
                },
                "Icon": "BOP"
            }


        }
        

    },

    "Problem Solving":{
        "Program Level": "Reason about computation and systems ~~ Technical skepticism",
        "Theory": "Use mathematical techniques to solve problems. Determine appropriate conceptual tools to apply to new situations. Know when tools do not apply and try different approaches. Critically analyze and evaluate candidate solutions.",
        "Children": { 
            "Propositional Logic": {
                "Description": "Reason about the truth or falsity of complicated statements using Boolean connectives, quantifiers, and basic definitions.",
                "Children": {
                    "Truth Tables": "Prove propositional equivalences using truth tables.",
                    "Laws or Known Propositional Logic": "Prove propositional equivalences using other known equivalences, e.g. DeMorgan’s laws, Double negation laws, Distributive laws, etc.",
                    "Consistency": "Decide and justify whether or not a collection of propositions is consistent.",
                    "Domain Elements": "Describe the set of domain elements that make a predicate with one input evaluate to true",
                    "Universal and Existential Statements": "Evaluate universal and existential statements about finite domains (with no quantifier alternations)."
                },
                "Icon": "PL"
            },

            "Proof Techniques": {
                "Description": "Apply proof techniques, including direct proofs and proofs by contradiction.",
                "Children": {
                    "Infinite Domains": "Counterexample and witness-based arguments for predicates with infinite domains",
                    "Nested Quantifiers": "Counterexample and witness-based arguments for nested quantifiers (both alternating and not)."
                },
                "Icon": "PT"
            },

            "Valid and Invalid Arguments": {
                "Description": "Distinguish valid from invalid arguments.",
                "Children": {
                    "Quantified Statement": "Determine what evidence is required to establish that a quantified statement is true or false.",
                    "Proposition and its Proof Strategies": "Identify the main connective of a proposition and associated proof strategies"
                },
                "Icon": "VA"
                
            },

            "Craft Proofs": {
                "Description": "Craft proofs and arguments at different levels of formality, including prose and symbolic notation as appropriate.",
                "Children": {
                    "Universal Generalization": "Use universal generalization to prove that universal statements are true.",
                    "Using Proofs to Evaluate Propositions": "Determine whether a proposition is true or false using valid reasoning (proofs) in multiple contexts.",
                    "Recursively Defined Sets and Functions": "Practice with properties of recursively defined sets and functions.",
                    "Proofs with Recursively Defined Sets and Functions": "Prove and disprove properties of recursively defined sets and functions with structural induction and/ or mathematical induction.",
                    "Induction Types": "Distinguish between and use as appropriate each of structural induction, mathematical induction, and strong induction.",
                    "Proof Technique": "Evaluate which proof technique(s) is appropriate for a given proposition.",
                    "Proof by Contradiction": "Trace and/or construct a proof by contradiction.",
                    "Mathematical Induction": "Use mathematical induction to prove statements about mathematical identities and inequalities.",
                    "Structural Induction": "Apply structural induction to prove statements about recursively defined objects, e.g. strings and trees."
                },
                "Icon": "CP"
            },

            "Binary Relations": {
                "Description": "Reason about binary relations",
                "Children": {
                    "Equivalence": "Define equivalence using relations and give examples",
                    "Congruence Modulo Integers": "Use the equivalence relation of congruence modulo integers and apply its properties",
                    "Properties": "Determine and prove whether a given binary relation is symmetric, antisymmetric, reflexive, and/or transitive",
                    "Equivalence Relation": "Determine and prove whether a given binary relation is an equivalence relation",
                    "Partial Order": "Determine and prove whether a given binary relation is a partial order" 
                },
                "Icon": "BR"
            },

            "Modular Arithmetic": {
                "Description": "Reason about modular arithmetic.",
                "Children": {
                    "Div and Mod Operators": "Define and use the div and mod operators."   
                },
                "Icon": "MA"
            },

            "Sets, Functions, and Relations Proof": {
                "Description": "Identify and be able to prove basic properties of sets, functions, and relations.",
                "Children": {
                    "Properties of Functions": "Compare sets using one-to-one, onto, and invertible functions.",
                    "Classifying the Cardinality of Sets": "Classify sets by cardinality into: Finite sets, countable sets, uncountable sets." 
                },
                "Icon": "SFR"
            }
        }

    },

    "Communication":{
        "Program Level": "Know, select and apply appropriate computing knowledge and problem-solving techniques ~~Multiple representations",
        "Theory":"Communication: Clearly and unambiguously communicate computational ideas using appropriate formalism. Translate across levels of abstraction.",
        "Children":{
            "Mathematical Definitions and Notation": {
                "Description":"Use and apply mathematical definitions and notation",
                "Children":{
                    "Data Types":"Define data types: set, n-tuple, string (over specific alphabet)",
                    "Sets and Functions":"Define sets and functions in multiple ways including recursively",
                    "Logical Connectors":"List the truth tables and meanings for conjunction, disjunction, exclusive or.",
                    "Compound Propositions":"Evaluate the truth value of a compound proposition given truth values of its constituent variables",
                    "Converse, Contrapositive, and Inverse":"Form the converse, contrapositive, and inverse of a given conditional statement",
                    "Evaluating Propositions":"Determine the truth value of the proposition resulting from evaluating a predicate",
                    "Factoring and Primes":"Define predicates associated with integer factoring and primes",
                    "Arbitrary":"Define “arbitrary”",
                    "Linked Lists":"Define linked lists as a recursively defined data structure",
                    "Cardinality Through Functions":"Define cardinality using one-to-one, onto, and invertible functions.",
                    "Important Number Sets":"Differentiate between important sets of numbers",
                    "Binary Relations":"Define (binary) relations and give examples."
                                
                },
                "Icon": "MDN"
            },

            "Algorithms in English/Pseudocode": {
                "Description":"Describe and trace simple algorithms using English and pseudocode.",
                "Children":{},
                "Icon": "AEP"
            },

            "Classical Algorithms":{
                "Description":"Define and use classical algorithms and algorithmic paradigms",
                "Children":{
                    "Convert Between Bases":"Convert between expansions in different bases of a positive integer.",
                    "Diffie-Hellman Key Exchange":"Trace the algorithms involved in Diffie-Helman key exchange",
                    "Modular Exponentiation":"Trace the algorithms involved in modular exponentiation",
                    "Hasse Diagram":"Draw the Hasse diagram of a partial order"
                },
                "Icon": "CA"
            },

            "Develop Algorithms":{
                "Description":"Use multiple representations of numbers to illustrate properties of the numbers and develop algorithms.",
                "Children":{
                    "Base Expansions":"Define the base expansion of a positive integer, specifically decimal, binary, hexadecimal, and octal",
                    "Representing Numbers":"Define multiple ways for representing numbers",
                    "Defining Ranges of Numbers":"Compute the ranges of numbers that can be represented using a given definition",
                    "Representing Negative Integers":"Represent negative integers in multiple ways",
                    "Operating on Numbers in Different Representations":"Perform arithmetic operations on integers using multiple representations",
                    "Relating Integer to Boolean Operations":"Relate algorithms for integer operations to bitwise boolean operations"
                },
                "Icon": "DA"
            },

            "Translating to Formal Logic":{
                "Description":"Translate sentences and specifications between English and formal logic.",
                "Children":{
                    "CNF/DNF":"Compute the CNF and DNF of a given compound proposition.",
                    "Translating to propositional logic":"Translate sentences from English to propositional logic using appropriate propositional variables and boolean operators.",
                    "Defining a Predicate over a Finite Domain":"Define a predicate over a finite domain using a table of values and as properties",
                    "Predicates with Tuples":"Use predicates with set of tuples as their domain to relate values to one another",
                    "Translate using logical connectors and universal and existential quantifiers":"Translate sentences with combinations of ∧, → in conjunction with universal and existential quantifiers",
                    "Use DeMorgan’s Law in Translating Quantified Statements":"State and apply DeMorgan’s law for quantified statements. aka Use logical equivalence to rewrite quantified statements (including negated quantified statements)"
                },
                "Icon": "FL"
            },

            "Cardinality of Sets":{
                "Description": "Distinguish between finite, countable, and uncountable sets.",
                "Children":{
                    "Cantor’s Diagonalization Argument":"Explain the central idea in Cantor’s diagonalization argument."
                },
                "Icon": "CD"
            }

        }

    }

}

